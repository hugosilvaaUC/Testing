import { Consents, UserConsentResponse } from './interfaces';
import { CONSENT_ACTION, CONSENT_TYPE } from '../DataFacade/enums';
import { TrackEventParameters } from '../DataFacade/interfaces';
import { DataTransferSettings } from '../../modules/helpers';
import { LegacyHashService, LegacySettings, ServiceHashArrayObject, Translations } from '../Settings/interfaces';
import { StorageTCF } from '../Storage/interfaces';
import { UserCountryResponse } from '../Location/interfaces';
declare global {
    interface Window {
        UC_AB_VARIANT?: string;
    }
}
export default class Api {
    private static instance;
    private API;
    private abTestVariant;
    private controllerIdInstance;
    private fetchUserCountryPromise;
    private jsonCacheBustingString;
    private jsonFileLanguage;
    private jsonFileVersion;
    private settingsId;
    private useEuCdn;
    private aggregatedServicesCache;
    private translationsCache;
    private constructor();
    static getInstance(): Api;
    static resetInstance(): void;
    resetAggregatedServicesCache(): void;
    resetTranslationsCache(): void;
    getAbTestVariant(): string;
    getJsonFileLanguage(): string;
    getJsonFileVersion(): string;
    getSettingsId(): string;
    setJsonCacheBustingString(jsonCacheBustingString: string): void;
    setJsonFileLanguage(jsonFileLanguage: string): void;
    setJsonFileVersion(jsonFileVersion: string): void;
    /**
     * When activated, only servers inside of the EU will be used
     *
     * @param activate
     */
    setSandboxMode(activate: boolean): void;
    setSettingsId(settingsId: string): void;
    /**
     * When activated, only servers inside of the EU will be used
     *
     * @param activate
     */
    setEuMode(activate: boolean): void;
    /**
     * Determine if API service was initialized in EU servers mode
     */
    isEuMode(): boolean;
    /**
     * Get the aggregator service URI
     *
     * @private
     */
    private getAggregatorUri;
    /**
     * Get the CDN URI containing JSON config files
     *
     * @private
     */
    private getCdnUri;
    /**
     * Get GraphQl URI
     *
     * @private
     */
    private getGraphQLUri;
    /**
     * Get the tcf data URI (v2)
     *
     * @private
     */
    private getTcfDataV2Uri;
    /**
     * Call aggregator service endpoint, which will return service
     */
    fetchAggregatedServices(language: string, servicesHashArray: ServiceHashArrayObject[], useCache?: boolean): Promise<LegacyHashService[]>;
    fetchAvailableLanguages(): Promise<string[]>;
    fetchTranslations(): Promise<Translations | null>;
    fetchSettingsJson(): Promise<LegacySettings>;
    fetchUserConsents(): Promise<UserConsentResponse[]>;
    fetchUserCountry(): Promise<UserCountryResponse>;
    fetchUserTcfData(): Promise<StorageTCF>;
    fetchUserTcfDataV2(): Promise<StorageTCF>;
    saveTCFConsents(dataTransferSettings: DataTransferSettings, storageTCF: StorageTCF, consentAction: CONSENT_ACTION, consentType: CONSENT_TYPE): Promise<void>;
    saveConsents(consents: Consents): Promise<void>;
    saveConsentsFromBuffer(): void;
    setTrackingPixel(parameters: TrackEventParameters, controllerId: string): void;
    updateTagLoggerData(targets: string[]): void;
    private addJsonCacheBustingString;
    private createAvailableLanguagesUrl;
    private createLanguagesUrl;
    private createSettingsJsonUrl;
    private createFetchUserConsentsUrl;
    private createFetchUserTcfDataUrl;
    private createFetchUserTcfDataV2Url;
    private saveTagLoggerData;
}
